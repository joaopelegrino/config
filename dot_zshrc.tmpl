# ~/.zshrc
# LIDO APENAS PARA SHELLS ZSH INTERATIVOS

# Suprimir warnings de completion de pacotes n√£o instalados (ex: Docker)
ZSH_DISABLE_COMPFIX=true

# --- SSH Agent Persistente ---
SSH_ENV="$HOME/.ssh/agent-environment"

function start_agent {
    echo "Initializing new SSH agent..."
    /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
    chmod 600 "${SSH_ENV}"
    . "${SSH_ENV}" > /dev/null
    /usr/bin/ssh-add ~/.ssh/id_ed25519 2>/dev/null
}

if [ -f "${SSH_ENV}" ]; then
    . "${SSH_ENV}" > /dev/null
    ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
        start_agent;
    }
else
    start_agent;
fi
# --- Fim SSH Agent Persistente ---

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
typeset -g POWERLEVEL9K_INSTANT_PROMPT=quiet
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Windows Terminal WSL2 - Enable true colors
export COLORTERM=truecolor

# --- Oh My Zsh ---
# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load
ZSH_THEME="powerlevel10k/powerlevel10k"

# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Add wisely, as too many plugins slow down shell startup.
# 'fzf' foi removido daqui pois carregamos manually abaixo com mais controle.
plugins=(
    git
    zsh-autosuggestions
    # z # REMOVIDO - Usando zoxide (Rust) em vez do plugin Z
    zsh-syntax-highlighting
    zsh-autocomplete # Deve vir DEPOIS de zsh-syntax-highlighting
)

# Carrega Oh My Zsh
source $ZSH/oh-my-zsh.sh
# --- Fim Oh My Zsh ---



# --- Configura√ß√µes do Usu√°rio ---
# NVM (Node Version Manager) - Carrega nvm, fun√ß√µes e completion
# NVM_DIR √© definido em ~/.zshenv
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # Carrega nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # Carrega nvm bash_completion para Zsh tamb√©m


# === Editor Aliases (Neovim - SSOT v3.2) ===
alias i='nvim'                                    # Neovim (padrao)
alias it='nvim -c "terminal"'                     # Neovim com terminal
alias iv='nvim -u NONE'                           # Neovim vanilla (sem config)
alias nved='nvim ~/.config/nvim/init.lua'         # Editar config nvim
alias tsined='cd ~/tsin.nvim && nvim .'           # Editar tsin.nvim

# === Vim Legacy (disponivel se necessario) ===
alias v='vim'                                     # Vim classico
alias vt='vim -c "terminal ++curwin"'             # Vim com terminal

alias c='clear'
alias la='ls -A' # Mostra ocultos exceto . e ..
alias ll='ls -alF' # Detalhado, ocultos, indicador de tipo

# --- Carregar Segredos e Vari√°veis do ~/.env ---
# √â crucial que o arquivo ~/.env N√ÉO esteja no seu reposit√≥rio Git.
# Adicione .env ao .gitignore do seu reposit√≥rio `~/config`.
if [[ -f "$HOME/.env" ]]; then
  # Exporta vari√°veis do tipo VAR=VALOR, ignorando coment√°rios e linhas em branco
  # Usar 'export $(...)' √© mais seguro que 'set -a' em alguns casos.
  export $(grep -vE '^\s*(#|$)' "$HOME/.env" | xargs)
  # Verifica se as vari√°veis esperadas foram carregadas (opcional, mas √∫til)
  # if [[ -z "$GH" ]]; then
  #   echo "Aviso: Vari√°vel GH n√£o encontrada em ~/.env ap√≥s sourcing." >&2
  # fi
  # if [[ -z "$OPENROUTER_API_KEY" ]]; then
  #   echo "Aviso: Vari√°vel OPENROUTER_API_KEY n√£o encontrada em ~/.env ap√≥s sourcing." >&2
  # fi
else
  # Aviso se o arquivo .env n√£o for encontrado
  echo "Aviso: Arquivo ~/.env n√£o encontrado. Segredos podem estar faltando." >&2
fi
# --- Fim Carregar Segredos ---

# Google ADK - Alias para ativar ambiente virtual
if [[ -n "$ADK_VENV_PATH" ]] && [[ -d "$ADK_VENV_PATH" ]]; then
  alias activate-adk="source $ADK_VENV_PATH/bin/activate"
fi

# --- Configura√ß√£o FZF ---
# Carrega configura√ß√µes, key bindings e completion do FZF.
# As vari√°veis FZF_* (comandos, op√ß√µes) devem estar DENTRO de ~/.fzf.zsh
# O path para o bin√°rio do fzf √© adicionado dentro de ~/.fzf.zsh
[[ -s "$HOME/.fzf.zsh" ]] && source "$HOME/.fzf.zsh"

# Atalhos FZF Customizados (Opcional - Descomente se necess√°rio e se estiverem DEPOIS do source)
# if [[ "$FZF_IS_WSL" -eq 1 ]] && { [[ "$TERM_PROGRAM" == *"WindowsTerminal"* ]] || [[ -n "$WT_SESSION" ]]; }; then
#    # Exemplo: Usar Ctrl+F em vez de Ctrl+T se Ctrl+T for capturado por outro programa
#    # bindkey '^F' fzf-file-widget
#    # bindkey '^O' fzf-cd-widget
#    # bindkey '^H' fzf-history-widget
# fi
# --- Fim Configura√ß√£o FZF ---


# --- Fun√ß√µes Customizadas ---
# Fun√ß√£o para adicionar um remote do GitHub usando token carregado do ~/.env
remoteadd() {
  local repo_name github_username remote_url

  # Verifica se um nome de reposit√≥rio foi fornecido
  if [ -z "$1" ]; then
    echo "Erro: Forne√ßa o nome do reposit√≥rio como argumento." >&2
    echo "Uso: remoteadd <nome-do-repositorio>" >&2
    return 1
  fi
  repo_name="$1"
  github_username="wmogh" # <-- CONFIRME/AJUSTE SE NECESS√ÅRIO

  # Verifica se a vari√°vel de token GH foi carregada do .env
  if [ -z "$GH" ]; then
    echo "Erro: Vari√°vel GH (token do GitHub) n√£o est√° definida." >&2
    echo "Certifique-se que GH=ghp_... existe em ~/.env e foi carregado." >&2
    return 1
  fi

  # Monta a URL do remote com o token
  remote_url="https://${GH}@github.com/${github_username}/${repo_name}.git"

  # Exibe uma mensagem (sem o token!) e executa o comando git
  echo "Executando: git remote add origin 'https://<SEU_TOKEN>@github.com/${github_username}/${repo_name}.git'"
  git remote add origin "$remote_url"

  # Verifica se o comando git falhou
  if [ $? -ne 0 ]; then
    echo "Aten√ß√£o: O comando 'git remote add' falhou." >&2
    echo "Verifique se o remote 'origin' j√° existe neste reposit√≥rio." >&2
    return 1
  fi

  echo "Remote 'origin' adicionado com sucesso para ${repo_name}."
}

# Fun√ß√£o para adicionar remote pessoal (notebook)
remoteadd_personal() {
  local repo_name personal_username remote_url

  # Verifica se um nome de reposit√≥rio foi fornecido
  if [ -z "$1" ]; then
    echo "Erro: Forne√ßa o nome do reposit√≥rio como argumento." >&2
    echo "Uso: remoteadd_personal <nome-do-repositorio>" >&2
    return 1
  fi
  repo_name="$1"
  personal_username="joaopelegrino"

  # Verifica se a vari√°vel de token GH foi carregada do .env
  if [ -z "$GH" ]; then
    echo "Erro: Vari√°vel GH (token do GitHub) n√£o est√° definida." >&2
    echo "Certifique-se que GH=ghp_... existe em ~/.env e foi carregado." >&2
    return 1
  fi

  # Monta a URL do remote pessoal com o token
  remote_url="https://${GH}@github.com/${personal_username}/${repo_name}.git"

  # Exibe uma mensagem (sem o token!) e executa o comando git
  echo "Executando: git remote add personal 'https://<SEU_TOKEN>@github.com/${personal_username}/${repo_name}.git'"
  git remote add personal "$remote_url"

  # Verifica se o comando git falhou
  if [ $? -ne 0 ]; then
    echo "Aten√ß√£o: O comando 'git remote add' falhou." >&2
    echo "Verifique se o remote 'personal' j√° existe neste reposit√≥rio." >&2
    return 1
  fi

  echo "Remote 'personal' adicionado com sucesso para ${personal_username}/${repo_name}."
}

# Fun√ß√£o para sincronizar com ambos os remotes (wmogh + notebook)
sync_repos() {
  local branch=$(git branch --show-current 2>/dev/null)
  local message="$1"
  
  if [ -z "$branch" ]; then
    echo "Erro: N√£o estamos em um reposit√≥rio Git ou branch n√£o encontrada." >&2
    return 1
  fi

  if [ -z "$message" ]; then
    message="üîÑ Sincroniza√ß√£o autom√°tica - $(date '+%Y-%m-%d %H:%M:%S')"
  fi

  echo "üîÑ Sincronizando branch '$branch'..."
  
  # Push para wmogh (origin)
  echo "üì§ Pushing para wmogh (origin)..."
  if git push origin "$branch"; then
    echo "‚úÖ Push para wmogh conclu√≠do"
  else
    echo "‚ùå Falha no push para wmogh"
    return 1
  fi
  
  # Push para notebook (personal) se existir
  if git remote get-url personal &>/dev/null; then
    echo "üì§ Pushing para notebook (personal)..."
    if git push personal "$branch"; then
      echo "‚úÖ Push para notebook conclu√≠do"
      echo "üéâ Sincroniza√ß√£o completa!"
    else
      echo "‚ùå Falha no push para notebook"
      return 1
    fi
  else
    echo "‚ö†Ô∏è  Remote 'personal' n√£o configurado. Use 'remoteadd_personal <repo-name>' para configurar."
  fi
}
# Fun√ß√£o para copiar caminho completo para clipboard
pwdc() {
  local full_path
  
  # Se um argumento foi fornecido, adiciona ao caminho
  if [ -n "$1" ]; then
    # Verifica se o arquivo/diret√≥rio existe
    if [ -e "$1" ]; then
      # Se existe, usa o caminho absoluto
      full_path="$(realpath "$1")"
    else
      # Se n√£o existe, apenas concatena com pwd
      full_path="$(pwd)/$1"
    fi
  else
    # Sem argumento, apenas o diret√≥rio atual
    full_path="$(pwd)"
  fi
  
  # Copia para clipboard (funciona no WSL)
  echo -n "$full_path" | clip.exe 2>/dev/null || echo -n "$full_path" | xclip -selection clipboard 2>/dev/null
  
  # Imprime o caminho copiado
  echo "üìã Copiado: $full_path"
}

# Fun√ß√£o para sincronizar Windows Terminal settings
sync-windows-terminal() {
  local wt_path="/mnt/c/Users/{{ .windows_username }}/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState"
  local chezmoi_config="$HOME/.config/windows-terminal/settings.json"

  if [ ! -f "$chezmoi_config" ]; then
    echo "‚ùå Config not found: $chezmoi_config"
    return 1
  fi

  if [ ! -d "$wt_path" ]; then
    echo "‚ùå Windows Terminal not found"
    return 1
  fi

  echo "üîÑ Syncing Windows Terminal settings..."
  cp "$chezmoi_config" "$wt_path/settings.json"

  if [ $? -eq 0 ]; then
    echo "‚úÖ Settings synced! Restart Windows Terminal to see changes."
  else
    echo "‚ùå Failed to sync settings"
    return 1
  fi
}

# Fun√ß√£o para mostrar caminho atual e tree da pasta
pwdct() {
  local current_path

  # Obt√©m o caminho atual
  current_path="$(pwd)"

  # Imprime o caminho atual
  echo "üìÅ $current_path"
  echo

  # Prepara o conte√∫do para clipboard
  local clipboard_content tree_output

  # Verifica se o comando tree est√° dispon√≠vel
  if command -v tree >/dev/null 2>&1; then
    echo "üå≥ Estrutura do diret√≥rio:"
    # Usa tree com op√ß√µes mais compat√≠veis e sem caracteres Unicode
    tree_output=$(tree -L 2 -a --dirsfirst --charset ascii)
    echo "$tree_output"
  else
    echo "üå≥ Estrutura do diret√≥rio (usando ls):"
    # Fallback usando ls com formato mais organizado
    tree_output=$(ls -laF --group-directories-first 2>/dev/null || ls -laF)
    echo "$tree_output"
  fi

  # Prepara conte√∫do completo para clipboard
  clipboard_content="$current_path"$'\n\n'"$tree_output"

  # Copia para clipboard (funciona no WSL)
  echo -n "$clipboard_content" | clip.exe 2>/dev/null || echo -n "$clipboard_content" | xclip -selection clipboard 2>/dev/null

  echo
  echo "üìã Conte√∫do copiado para clipboard!"
}

# --- Fim Fun√ß√µes ---

# --- Configura√ß√£o Vari√°veis Github ---
ORGANIZATION_NAME="wmogh"
# Nome da organiza√ß√£o ou usu√°rio do GitHub
REPO_NAME="saas-saude"
SCRIPT_NAME="estruturaissue.sh" # Nome do script que voc√™ forneceu
# --- Powerlevel10k ---
# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
# Carrega a configura√ß√£o do P10k (deve vir por √∫ltimo ou quase √∫ltimo)
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
# --- Fim Powerlevel10k ---

# --- PATH Configuration ---
# Organizando PATH de forma limpa e sem duplica√ß√µes
# Adicionar apenas se ainda n√£o estiver no PATH
[[ ":$PATH:" != *":$HOME/.local/bin:"* ]] && export PATH="$HOME/.local/bin:$PATH"
[[ ":$PATH:" != *":$HOME/.npm-global/bin:"* ]] && export PATH="$HOME/.npm-global/bin:$PATH"

# --- Aliases ---


# Shell reload - Recarregar todas as configura√ß√µes
alias reload="source ~/.zshenv && source ~/.zshrc && source ~/.p10k.zsh && source ~/.fzf.zsh"

# Atalhos para projetos e configura√ß√µes (SSOT via chezmoi)
alias zed="nvim ~/.local/share/chezmoi/dot_zshrc.tmpl"         # Editar zshrc (chezmoi source)
alias ved="nvim ~/.local/share/chezmoi/dot_vimrc"              # Editar vimrc (chezmoi source)
alias ched="cd ~/.local/share/chezmoi && nvim ."               # Editar chezmoi dotfiles
alias wted="nvim '/mnt/c/Users/valor/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json'"

# LLM template aliases
alias llm-new='~/config/create-llm-template.sh'
alias llm-main='vim /home/notebook/workspace/blog/.claude/commands/LLM-main.md'
alias llm-copy='cp /home/notebook/workspace/blog/.claude/commands/LLM-main.md'

# ========================================
# Yazi File Manager Integration
# ========================================

# Function to integrate yazi with shell (change directory on exit)
function yy() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
    yazi "$@" --cwd-file="$tmp"
    if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
        builtin cd -- "$cwd"
    fi
    rm -f -- "$tmp"
}

# opencode
export PATH=/home/notebook/.opencode/bin:$PATH

# ========================================
# Obsidian Configuration
# ========================================
export OBSIDIAN_HOME=~/Documents/Obsidian
export OBSIDIAN_BIN=~/Applications/Obsidian-1.7.7.AppImage

# Obsidian aliases
alias obs='nohup $OBSIDIAN_BIN --no-sandbox > /dev/null 2>&1 &'  # Abre Obsidian em background
alias obsidian='nohup $OBSIDIAN_BIN --no-sandbox > /dev/null 2>&1 &'  # Alias completo
alias obs-vault='nohup $OBSIDIAN_BIN --no-sandbox $OBSIDIAN_HOME > /dev/null 2>&1 &'  # Abre diret√≥rio padr√£o
alias obs-kill='pkill -f Obsidian'  # Fecha todos os processos do Obsidian
alias obs-status='ps aux | grep -i obsidian | grep -v grep'  # Verifica status do Obsidian
export PATH="$HOME/.local/bin:$PATH"

# === Aliases de Produtividade ===
# Docker aliases
alias dps="docker ps"
alias dpa="docker ps -a"
alias di="docker images"
alias dex="docker exec -it"
alias dc="docker compose"
alias dcu="docker compose up -d"
alias dcd="docker compose down"
alias dcl="docker compose logs -f"

# Git aliases adicionais
alias gst="git status -sb"
alias gco="git checkout"
alias gcm="git commit -m"
alias glog="git log --oneline --graph --decorate"
alias gp="git push"
alias gl="git pull"
alias gd="git diff"

# Fun√ß√£o para estado geral do reposit√≥rio git (n√£o-interativo)
gitoverview() {
  local output

  # Captura toda a sa√≠da em uma vari√°vel
  output=$(cat <<EOF
üìä Estado Geral do Reposit√≥rio Git
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìÅ Branch atual:
$(git branch --show-current 2>/dev/null)

üåê Remotes configurados:
$(git remote -v 2>/dev/null)

üåø Todas as branches (locais e remotas):
$(git --no-pager branch -a --sort=-committerdate 2>/dev/null)

üìã Status do reposit√≥rio:
$(git status -sb 2>/dev/null)

üìà √öltimos 5 commits:
$(git --no-pager log --oneline -5 2>/dev/null)

üîÑ Compara√ß√£o com remote (se dispon√≠vel):
$(
  comparison=$(git rev-list --left-right --count HEAD...@{upstream} 2>/dev/null)
  if [ $? -eq 0 ] && [ -n "$comparison" ]; then
    echo "$comparison" | awk '{
      if($1>0) print "‚Üë " $1 " commits para push"
      if($2>0) print "‚Üì " $2 " commits para pull"
      if($1==0 && $2==0) print "‚úÖ Branch sincronizada com remote"
    }'
  else
    echo 'Branch n√£o est√° tracking um remote'
  fi
)
EOF
)

  # Exibe a sa√≠da no terminal
  echo "$output"
  echo

  # Copia para clipboard (funciona no WSL)
  echo -n "$output" | clip.exe 2>/dev/null || echo -n "$output" | xclip -selection clipboard 2>/dev/null

  # Confirma que foi copiado
  echo 'üìã Resultado copiado para clipboard!'
}

# Navega√ß√£o r√°pida
alias conf="cd ~/config"
alias desktop="cd /mnt/c/Users/valor/Desktop"

# Desenvolvimento
alias ports="netstat -tulanp"

# ========================================
# Gerador de Aliases de Edi√ß√£o
# ========================================

# Fun√ß√£o para gerar aliases de edi√ß√£o personalizados
# Uso: mkalias [nome_completo_alias] [caminho_absoluto]
# Exemplo: mkalias gited /home/notebook/config/gitconfig
# Exemplo: mkalias nvimed ~/.config/nvim/init.vim
# Resultado: alias gited="vim /home/notebook/config/gitconfig"
mkalias() {
  local alias_name full_path
  
  # Verifica se ambos os argumentos foram fornecidos
  if [ $# -ne 2 ]; then
    echo "‚ùå Uso: mkalias <nome_alias> <caminho_absoluto>" >&2
    echo "üìù Exemplo: mkalias gited /home/notebook/config/gitconfig" >&2
    echo "üìù Exemplo: mkalias nvimed ~/.config/nvim/init.vim" >&2
    echo "üìÑ Resultado: alias criado para editar o arquivo" >&2
    return 1
  fi
  
  alias_name="$1"
  full_path="$2"
  
  # Verifica se o arquivo existe
  if [ ! -f "$full_path" ]; then
    echo "‚ö†Ô∏è  Arquivo n√£o encontrado: $full_path" >&2
    echo "ü§î Deseja criar o alias mesmo assim? (y/N)"
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      echo "‚ùå Opera√ß√£o cancelada."
      return 1
    fi
  fi
  
  # Cria o alias temporariamente na sess√£o atual
  alias "$alias_name"="vim '$full_path'"
  
  # Adiciona permanentemente ao zshrc
  echo "alias $alias_name=\"vim '$full_path'\"" >> /home/notebook/config/zshrc
  
  # Feedback para o usu√°rio
  echo "‚úÖ Alias criado com sucesso!"
  echo "üìã Comando: alias $alias_name=\"vim '$full_path'\""
  echo "üîÑ Execute 'reload' para aplicar em novas sess√µes, ou use j√° na sess√£o atual."
  echo "üìç Adicionado ao final do arquivo zshrc"
}

alias cced="vim '/home/notebook/workspace/especialistas/claude-code/acao-cc.md'"
alias arch="vim '/home/notebook/workspace/especialistas/fundamentos/guias-passo-a-passo/arch-minimal-setup.md'"

alias concat-md="PROJETO=\$(basename \"\$PWD\" | tr \"a-z-\" \"A-Z_\"); { echo \"# üìö \$PROJETO - DOCUMENTA√á√ÉO COMPLETA\"; echo \"**Gerado em:** \$(date)\"; echo \"\"; find . -name \"*.md\" -type f | sort | while read file; do echo -e \"\n---\n## üìÅ \$file\n\"; cat \"\$file\"; done; } > \"\${PROJETO}_COMPLETO.md\" && echo \"‚úÖ Gerado: \${PROJETO}_COMPLETO.md\""

alias concat-parcial='concat_parcial_files() {
  if [ $# -eq 0 ]; then
    echo "‚ùå Uso: concat-parcial <arquivo1.md> <arquivo2.md> [...]"
    echo "   Exemplo: concat-parcial README.md INSTALL.md CONFIG.md"
    return 1
  fi
  
  PROJETO=$(basename "$PWD" | tr "a-z-" "A-Z_")
  OUTPUT_FILE="${PROJETO}_ARQUIVOS_IMPORTANTES.md"
  
  {
    echo "# üìö $PROJETO - ARQUIVOS IMPORTANTES"
    echo "**Gerado em:** $(date)"
    echo "**Arquivos inclu√≠dos:** $*"
    echo ""
    
    for file in "$@"; do
      if [ -f "$file" ]; then
        echo -e "\n---\n## üìÅ $file\n"
        cat "$file"
      else
        echo -e "\n---\n## ‚ùå $file (n√£o encontrado)\n"
      fi
    done
  } > "$OUTPUT_FILE"
  
  echo "‚úÖ Gerado: $OUTPUT_FILE"
}; concat_parcial_files'

alias vnotas="vim '/home/notebook/workspace/especialistas/aplicando/notas11-09.md'"
alias ned="vim '/home/notebook/workspace/especialistas/desenvovlimento/notas/notas-12-09.md'"
alias sessao='script -c "zsh -c \"PROMPT=\\\"$ \\\" exec zsh\"" ~/logs/sessoes/sessao-$(date +%Y%m%d_%H%M%S)-essencial.txt'


# ========================================
# Claude Code Aliases
# ========================================
alias claude="/home/notebook/.claude/local/claude"

# Claude com permiss√µes bypassed (para ambientes sandbox/desenvolvimento)
alias cs="claude --dangerously-skip-permissions"

# Claude resume - retomar conversas existentes
alias cr="claude --dangerously-skip-permissions --resume"

alias pwds="pwdct_simple"

# Warp Terminal Configuration - Added seg 15 set 2025 07:18:25 -03
# Previne conflitos de notebook creation no Warp
export WARP_CONFIG_DIR="$HOME/.warp"
[ -f "$HOME/.warp/startup.sh" ] && source "$HOME/.warp/startup.sh"

export WASMTIME_HOME="$HOME/.wasmtime"

export PATH="$WASMTIME_HOME/bin:$PATH"
. "$HOME/.asdf/asdf.sh"
# Append asdf completions to fpath (Zsh native)
fpath=(${ASDF_DIR}/completions $fpath)
# Initialize completions with autocomplete
autoload -Uz compinit
compinit

# ========================================
# ERLANG/OTP COMPILATION OPTIONS
# ========================================
export KERL_CONFIGURE_OPTIONS="--without-javac --with-ssl"

# ========================================
# ELIXIR/OTP ENVIRONMENT (Healthcare Stack)
# ========================================
# Unicode support para filenames (ex: caf√©.ex)
export ELIXIR_ERL_OPTIONS="+fnu"

# Habilita hist√≥rico persistente no IEx
export ERL_AFLAGS="-kernel shell_history enabled"

# Define ambiente padr√£o do Mix (dev/test/prod)
export MIX_ENV=dev

# Aumenta limite de file descriptors para Phoenix/LiveView
# WSL2 j√° tem limite alto (1M), mas garantimos o m√≠nimo recomendado
ulimit -n 65536 2>/dev/null || true

# ========================================
# C-ELIXIR-WASM STACK CONFIGURATION
# ========================================
# Emscripten (C/C++ ‚Üí WASM compiler)
export EMSDK_QUIET=1  # Suprimir mensagens autom√°ticas
source ~/emsdk/emsdk_env.sh

# WASI SDK (C ‚Üí WASI compiler)
export WASI_SDK_PATH=/opt/wasi-sdk
export PATH="$WASI_SDK_PATH/bin:$PATH"

# Alias para valida√ß√£o da stack C-Elixir-WASM
alias check-wasm='cd ~/workspace/ambiente-iniciar && bash scripts/validate_stack_c_elixir_wasm.sh'
alias validate-stack='check-wasm'  # Alias alternativo

# ========================================
# Gemini CLI Configuration
# ========================================

# Alias b√°sico - sempre usa a vers√£o mais recente dispon√≠vel no npm
alias gemini='npx @google/gemini-cli@latest'

# Alias para vers√£o espec√≠fica (stable)
alias gemini-stable='npx @google/gemini-cli@0.8.1'

# Alias para vers√£o preview (mais recente com recursos experimentais)
alias gemini-preview='npx @google/gemini-cli@0.9.0-preview.0'

# Alias para vers√£o nightly (bleeding edge - pode ser inst√°vel)
alias gemini-nightly='npx @google/gemini-cli@nightly'

# Fun√ß√£o avan√ßada: gerencia vers√µes e exibe informa√ß√µes
gemini-info() {
  echo "üì¶ Informa√ß√µes do Gemini CLI"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo
  echo "üìå Vers√£o instalada globalmente:"
  npm list -g @google/gemini-cli 2>/dev/null | grep @google/gemini-cli || echo "  Nenhuma vers√£o global instalada"
  echo
  echo "üåê √öltima vers√£o est√°vel dispon√≠vel:"
  npm view @google/gemini-cli version 2>/dev/null || echo "  Erro ao consultar npm"
  echo
  echo "üîÆ √öltima vers√£o preview dispon√≠vel:"
  npm view @google/gemini-cli@preview version 2>/dev/null || echo "  Nenhuma preview dispon√≠vel"
  echo
  echo "üöÄ Aliases dispon√≠veis:"
  echo "  gemini          ‚Üí npx @google/gemini-cli@latest (sempre atualizado)"
  echo "  gemini-stable   ‚Üí npx @google/gemini-cli@0.8.1"
  echo "  gemini-preview  ‚Üí npx @google/gemini-cli@0.9.0-preview.0"
  echo "  gemini-nightly  ‚Üí npx @google/gemini-cli@nightly"
  echo
  echo "üí° Comandos √∫teis:"
  echo "  gemini-update   ‚Üí Atualiza instala√ß√£o global"
  echo "  gemini-clean    ‚Üí Remove cache e reinstala"
}

# Fun√ß√£o para atualizar instala√ß√£o global (se existir)
gemini-update() {
  echo "üîÑ Atualizando Gemini CLI..."
  if npm list -g @google/gemini-cli &>/dev/null; then
    npm update -g @google/gemini-cli
    echo "‚úÖ Atualiza√ß√£o conclu√≠da!"
  else
    echo "‚ÑπÔ∏è  Nenhuma instala√ß√£o global encontrada."
    echo "üí° Use 'npm install -g @google/gemini-cli@latest' para instalar globalmente"
  fi
}

# Fun√ß√£o para limpar cache e reinstalar
gemini-clean() {
  echo "üßπ Limpando instala√ß√£o do Gemini CLI..."
  npm uninstall -g @google/gemini-cli 2>/dev/null
  npm cache clean --force
  echo "üì¶ Reinstalando vers√£o mais recente..."
  npm install -g @google/gemini-cli@latest
  echo "‚úÖ Limpeza e reinstala√ß√£o conclu√≠das!"
}

# Fun√ß√£o para comparar vers√µes dispon√≠veis
gemini-versions() {
  echo "üìã Vers√µes dispon√≠veis do Gemini CLI"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo
  echo "üè∑Ô∏è  Vers√µes est√°veis recentes:"
  npm view @google/gemini-cli versions --json | grep -v nightly | tail -10
  echo
  echo "üîÆ Vers√µes preview recentes:"
  npm view @google/gemini-cli versions --json | grep preview | tail -5
}

# ==============================================================================
# MISE (Version Manager) - Gerenciado por chezmoi
# ==============================================================================
if [ -f "$HOME/.local/bin/mise" ]; then
    eval "$(~/.local/bin/mise activate zsh)"
fi

# ==============================================================================
# STARSHIP (Prompt) - Gerenciado por chezmoi
# ==============================================================================
# Comentar P10K se quiser usar Starship
# if command -v starship &> /dev/null; then
#     eval "$(starship init zsh)"
# fi

# ==============================================================================
# MODERN CLI ALIASES (gerenciado por mise via chezmoi)
# ==============================================================================
# Estes aliases s√≥ funcionam se as ferramentas forem instaladas via mise

# Bat (cat com syntax highlighting)
if command -v bat &> /dev/null; then
    alias cat='bat --paging=never'
    alias catp='bat'
fi

# Eza/Lsd (ls moderno) - Prioriza eza se ambos instalados
if command -v eza &> /dev/null; then
    # Eza (sucessor do exa/lsd) - Mais recursos e melhor manuten√ß√£o
    alias ls='eza --icons --group-directories-first'
    alias ll='eza -l --icons --group-directories-first --git'
    alias la='eza -la --icons --group-directories-first --git'
    alias lt='eza --tree --icons --level=2'
    alias lta='eza --tree --icons --level=3'
    alias laa='eza -la --icons --group-directories-first --git --header --time-style=long-iso'
elif command -v lsd &> /dev/null; then
    # Lsd (fallback se eza n√£o estiver instalado)
    alias ls='lsd'
    alias ll='lsd -l'
    alias la='lsd -la'
    alias lt='lsd --tree'
fi

# Ripgrep (grep ultra-r√°pido)
if command -v rg &> /dev/null; then
    alias grep='rg'
fi

# Fd (find moderno)
if command -v fd &> /dev/null; then
    alias find='fd'
fi

# Bottom (monitor de recursos)
if command -v btm &> /dev/null; then
    alias top='btm'
fi

# Dust (visualizador de uso de disco)
if command -v dust &> /dev/null; then
    alias du='dust'
fi

# ==============================================================================
# ZOXIDE (Smarter CD) - Ferramenta Rust para navega√ß√£o inteligente
# ==============================================================================
# Zoxide substitui o plugin 'z' com melhor performance (10-50x mais r√°pido)
# Database: SQLite interno (~/.local/share/zoxide/db.zo)
# Algoritmo: Frecency avan√ßado (frequency + recency)
if command -v zoxide &> /dev/null; then
    eval "$(zoxide init zsh)"

    # Aliases de navega√ß√£o
    alias cd='z'        # cd usa zoxide
    alias cdi='zi'      # cd interativo (com fzf)

    # Utilit√°rios zoxide
    alias zq='zoxide query'           # Query sem navegar
    alias zl='zoxide query --list'    # Lista database completo
    alias zr='zoxide remove'          # Remove entrada do database
    alias zs='zoxide query --score'   # Mostra scores
fi
